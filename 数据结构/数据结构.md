# 一.常见数据结构（特点、实现方式）

## 0.数据结构描述

- 数据结构是计算机**底层存储、组织数据**的方式。是指数据相互之间是以什么方式排列在一起的。
- 数据结构是为了更加方便的**管理和使用数据**，需要**结合具体的业务场景**来进行选择。一般情况下，精心选择的数据结构可以带来**更高的运行或者存储效率**。

## 1.数组

特点：**查询快，增删慢**

1. **查询速度快**：查询数据通过地址值和索引定位，查询任意数据耗时相同。（**元素在内存中是连续存储的**）
2. **删除效率低**：要将原始数据删除，同时后面每个数据前移。
3. **添加效率低**：添加位置后的每个数据后移，再添加元素。

## 2.链表

特点：**增删快，查询慢**

**查询慢**，无论查询哪个数据都要从头开始找。

**增删快**，只需修改相连结点的下一结点地址。

实现方式：

链表里的每个元素称为**结点（Node），结点的存储位置**就是**地址**

结点中存储**具体的数据**和**下一个结点的地址**

<img src="tupian\image-20230201164733412-1675488314372-10.png" alt="image-20230201164733412" style="zoom: 50%;" />

创建一个链表：

<img src="tupian\image-20230201164934255-1675488314372-9.png" alt="image-20230201164934255" style="zoom:50%;" />



*链表中的每个结点是**独立的对象**，在**内存中是不连续**的，每个结点包含**数据值**和**下一个结点的地址***

————————————

### 双向链表（提高了查询效率）

**查询的元素离头近就从前找，离尾近就从后找**

<img src="tupian\image-20230201165651877-1675488314373-11.png" alt="image-20230201165651877" style="zoom:50%;" />

结点中存储**具体的数据**，**下一个结点的地址**和**上一个结点的地址**

## 3.栈

特点：**先进后出，后进先出**

<img src="tupian\image-20230201163125229-1675488314373-12.png" alt="image-20230201163125229" style="zoom:33%;" />

*栈就和弹夹一样，一边开口一边封闭，最先进去的子弹，最后被打出来*

数据**进入**栈模型的过程称为：**压栈/进栈**

数据**离开**栈模型的过程称为：**弹栈/出栈**

Java中的栈内存：**方法运行时进栈，执行完毕出栈**

## 4.队列

特点：**先进先出，后进后出**

<img src="tupian\image-20230201163649800-1675488314373-13.png" alt="image-20230201163649800" style="zoom:33%;" />

数据从后端进入队列的过程称为：**入队列**

数据从前端离开队列的过程称为：**出队列**

## 5.二叉树

特点：每个结点最多只能有两个子节点

**度**：每一个节点的子节点数量（任意节点的度<=2）

**树高**：树的总层数（下图为4层）

**根节点**：最顶层的节点（下图为22）

**左子节点**：左下方的节点（22的左子节点为18）

**右子节点**：右下方的节点（22的右子节点为26）

**根节点的左子树**：蓝色虚线（26的左子树是24、23、25）

**根节点的右子树**：绿色虚线（26的右子树是28、27、29）

<img src="tupian\image-20230201171220030-1675488314373-15.png" alt="image-20230201171220030" style="zoom: 50%;" />

节点中存储的是：**父节点地址**+**数据值**+**左子节点地址**+**右子节点地址（地址空为NULL）**

<img src="tupian\image-20230201170535394-1675488314373-14.png" alt="image-20230201170535394" style="zoom: 50%;" />

**遍历方式**

**①前序遍历**

从**根结点开始**，然后按照**当前**结点，**左**子结点，**右**子结点的顺序遍历

<img src="tupian\image-20230201172243062-1675488314373-16.png" alt="image-20230201172243062" style="zoom: 33%;" />遍历结果为:20→18→16→19→23→22→24

**②中序遍历（常用）**

从**最左边子节点开始**，然后按照**左**子节点，**当前**节点，**右**子节点的顺序遍历

<img src="tupian\image-20230201172243062-1675488314373-16.png" alt="image-20230201172243062" style="zoom: 33%;" />遍历结果为:16→18→19→20→22→23→24

**③后序遍历**

从**最左边子节点开始**，然后按照**左**子节点，**右**节点，**当前**子节点的顺序遍历

<img src="tupian\image-20230201172243062-1675488314373-16.png" alt="image-20230201172243062" style="zoom: 33%;" />遍历结果为:16→19→18→22→24→23→20

**④层序遍历**

从根节点开始**一层一层**的遍历

<img src="tupian\image-20230201172243062-1675488314373-16.png" alt="image-20230201172243062" style="zoom: 33%;" />遍历结果为:20→18→23→16→19→22→24



## 6.二叉查找树

**二叉查找树，又称二叉排序树或者二叉搜索树**

特点：

- 每一个节点上**最多**有两个子节点
- 任意节点左子树上的值都**小于**当前节点
- 任意节点右子树上的值都**大于**当前节点

- 添加节点规则：**小的存左边、大的存右边、一样的不存**


- 查找节点规则：**小的查左边、大的查右边、一样查到了**

<img src="tupian\image-20230201171910304-1675488314373-17.png" alt="image-20230201171910304" style="zoom:33%;" />



**弊端**

- 当所有节点都是右子节点或左子节点的时候，查询效率就会很低，类似于链表

<img src="tupian\image-20230201173340167-1675488314373-18.png" alt="image-20230201173340167" style="zoom: 50%;" />

## 7.平衡二叉树

**规则**：任意节点的左右子树高度差**不超过1**

<img src="tupian\image-20230201173928366-1675488314373-19.png" alt="image-20230201173928366" style="zoom: 25%;" />

<img src="tupian\image-20230201174103602.png" alt="image-20230201174103602" style="zoom: 33%;" />



**旋转机制（保持平衡的机制）**：

- 触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树
- 规则1：**左旋（右子节点层数比左子节点层数大于1）**
  - **确定支点**：从**添加的节点**开始，不断的往父节点找不平衡的节点
  - **简单情况**
    - <img src="tupian\image-20230203123641379.png" alt="image-20230203123641379" style="zoom: 50%;" />→<img src="tupian\image-20230203123704311.png" alt="image-20230203123704311" style="zoom: 67%;" />
    - 以**不平衡的点为支点**，把**支点左旋降级**，变为左子节点，**晋升原来的右子节点**
  - **复杂情况（支点的子节点有左右子节点）**
    - <img src="tupian\image-20230203124300968.png" alt="image-20230203124300968" style="zoom:50%;" />→<img src="tupian\image-20230203124543397.png" alt="image-20230203124543397" style="zoom: 50%;" />→<img src="tupian\image-20230203124359857.png" alt="image-20230203124359857" style="zoom: 67%;" />
    - 以**不平衡的点为支点**，将**根节点的右侧向左拉**，原先的右子节点变成新的父节点，**多余的左子节点传给已经降级的根节点当右子节点**
- 规则2：**右旋（左子节点层数比右子节点层数大于1）**
  - 与左旋正好相反




**平衡二叉树需要旋转的四种情况**

- **左左（一次右旋）**：当根节点左子树的左子树有节点插入，导致二叉树不平衡
- **左右（先 局部/根节点的左子树 左旋变为左左，再整体右旋）**：当根节点左子树的右子树有节点插入，导致二叉树不平衡
  - <img src="tupian\image-20230203125907861.png" alt="image-20230203125907861" style="zoom:50%;" />→<img src="tupian\image-20230203125936138.png" alt="image-20230203125936138" style="zoom:50%;" />→<img src="tupian\image-20230203130036884.png" alt="image-20230203130036884" style="zoom:45%;" />
- **右右（一次左旋）**：当根节点右子树的右子树有节点插入，导致二叉树不平衡
- **右左（先 局部/根节点的右子树 右旋变为右右，再整体左旋）**：当根节点右子树的左子树有节点插入，导致二叉树不平衡



**弊端（因此有了红黑树等其他更高效率的二叉树）**

- 当左右子树高度差超过1时，就要通过旋转保持平衡，频繁的旋转降低了效率



**平衡二叉树常见问题**

<img src="tupian\image-20230203130725097.png" alt="image-20230203130725097" style="zoom: 67%;" />

## 8.红黑树（不是平衡二叉树）

- 红黑树是一种**自平衡的二叉查找树**，是计算机科学中的一种数据结构。
- 1972年出现，原名平衡二叉B树，1978年改为红黑树。
- 它是一种特殊的**二叉查找树**，每一个节点**都有存储位表示节点的颜色**
- **每一个节点可以是红或者黑**；红黑树**不是高度平衡的**，它的平衡是通过”**红黑规则**“进行实现的
- 增删改查性能都很好

<img src="tupian\image-20230203131858926.png" alt="image-20230203131858926" style="zoom: 60%;" /> <img src="tupian\image-20230203144418054.png" alt="image-20230203144418054" style="zoom: 60%;" />    

​							*是一个**二叉查找树**，但**不是高度平衡**的，**特有红黑规则***

**红黑规则**

①每一个节点**或是红色**的，**或是黑色**的

②**根节点必须是黑色的**

③如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为**Nil**，这些Nil视为叶节点，每一个**叶节点（Nil）是黑色的**

④如果某一个节点是红色的，那么它的子节点必须为黑色（**不能出现两个红色节点相连的情况**）

⑤**对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点**



**添加节点规则**

- **默认颜色**：添加的节点默认是**红色**的（**效率高**）
  - 添加三个节点，如果默认是黑色的需要调整两次，红色只需调整一次

<img src="tupian\image-20230203155455670.png" alt="image-20230203155455670"  />

# 二.算法

## 1.查找算法

### 1.基本查找/顺序查找/线性查找

**基本思想**：也叫顺序查找或者线性查找。从数据结构的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。

```java
public static boolean basicSearch(int[] arr, int number){
    //参数：1.数组2.要查找的元素
	//返回值：元素是否存在
    for (int i = 0; i < arr.length; i++) {
        if(arr[i] == number){
            return true;
        }
    }
    return false;
}
```

### 2.二分查找/折半查找

**前提条件**：数组中的数据**必须是有序的（从大到小或从小到大都可以）**

> 排序之后再查找返回的索引无实际意义

**核心逻辑**：每次排除一半的查找范围

**基本思想**：属于有序查找算法。先确定要查找的范围（left和right），然后可得到中间结点的值（mid=（left+right）/2）但是left+right可能会超过int的最大值，造成溢出，所以一般写成mid = right+（left-right）/2，然后用要查找的元素和中间值进行比较。比较完之后有三种情况：

* 相等：说明找到了

* 要查找的数据比中间节点小：说明要查找的数字在中间节点左边

* 要查找的数据比中间节点大：说明要查找的数字在中间节点右边

> mid=（left+right）/2=（left+right-right+right）/2=（left+2max-right）/2
>
> =right（left-right）/2

**与基本查找相比，有什么优势？**提高查找效率

**二分查找的前提条件？**数据必须是有序的

```java
public static int binarySearch(int[] arr, int number){
    //1.定义两个变量记录要查找的范围
    int left = 0;
    int right = arr.length - 1;
    //2.利用循环不断的去找要查找的数据
    while(true){
        if(left > right){
            return -1;
        }
        //3.找到left和right的中间位置
        int mid = (left + right) / 2;
        //4.拿着mid指向的元素跟要查找的元素进行比较
        if(arr[mid] > number){
            //4.1 number在mid的左边
            //left不变，right = mid - 1；
            right = mid - 1;
        }else if(arr[mid] < number){
            //4.2 number在mid的右边
            //right不变，left = mid + 1;
            left = mid + 1;
        }else{
            //4.3 number跟mid指向的元素一样
            //找到了
            return mid;
        }}}
```

### 3.插值查找

插值查找是在二分查找的基础上，让中间点mid更接近要查找的元素，也属于有序查找。

![image-20230203171433266](tupian\image-20230203171433266.png)

**适用情况**：对于数据很多的表，并且数据**分布比较均匀**的表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

代码与二分查找类似，仅仅mid的计算方式不同

### **4.斐波那契查找**

**基本思想**：斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式。同样地，斐波那契查找也属于一种有序查找算法。

**斐波那契数列**：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….

mid = left + 黄金分割点左半边长度 -1

![image-20230203172145160](tupian\image-20230203172145160.png)

### 5.分块查找

当数据表中的数据元素很多时，可以采用分块查找。

**分块的原则**

![image-20230203182122764](tupian\image-20230203182122764.png)

<img src="tupian\image-20230203182349648.png" alt="image-20230203182349648" style="zoom: 67%;" />

- 前一块中最大的数据，小于后一块中所有的数据（块内无序，块间有序）
- 块的数量一般是表长的开根号。例如长度为16的表分为4块。
- 块对象中的属性：max，startIndex，endIndex；

**分块查找的过程**

1. 需要把数据分成N多小块，块与块之间不能有数据重复的交集。
2. 给每一块创建对象单独存储到块数组当中
3. 查找数据的时候，先在数组查当前的数据属于哪一块
4. 再到这一块中进行顺序查找

**分块查找的拓展（无规律的数据）**

![image-20230203182219406](tupian\image-20230203182219406.png)

- 块对象中的属性：min，max，startIndex，endIndex；

**分块查找的拓展（查找过程中还要添加数据）**

<img src="tupian\image-20230203182742310.png" alt="image-20230203182742310" style="zoom: 67%;" />

<img src="tupian\image-20230203183041166.png" alt="image-20230203183041166" style="zoom:50%;" />

​														*类似于**哈希查找***

### 6.哈希查找

哈希查找是分块查找的进阶版，适用于**数据一边添加一边查找**的情况。

**添加数据方式**：计算出当前数据的哈希值，用哈希值跟数组的长度进行取余计算（散列函数），计算出应存入的位置，再挂在数组的后面**形成链表**，如果挂的元素太多而且数组长度过长，我们也会把链表**转化为红黑树**，进一步提高效率。（传说中的哈希表）

### 7.树表查找

**基本思想**：二叉查找树的规律，小的查当前节点左边的子节点，大的查右边当前节点右边的子节点。**遍历常用中序遍历**

## 2.排序算法

### 1.冒泡排序

**算法步骤**：

1. **相邻的元素两两比较**，小的放前面，大的放后面
2. 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推
3. 如果数组中有n个数据，总共我们只要**执行n-1轮的代码**就可以

<img src="tupian\0maopao.gif" alt="冒泡" style="zoom:67%;" />

```java
//外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮
for (int i = 0; i < arr.length - 1; i++) {
    //内循环：每一轮中比较数据并找到当前的最大值
    //-1：为了防止索引越界
    //-i：提高效率，每一轮执行的次数应该比上一轮少一次。
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }}}
```

### 2.选择排序

**算法步骤**：

1. 从0索引开始，跟后面的元素一一比较，小的放前面，大的放后面
2. 第一次循环结束后，最小的数据已经确定
3. 第二次循环从1索引开始以此类推
4. 第三轮循环从2索引开始以此类推

<img src="tupian\0xuanze.gif" alt="选择排序" style="zoom:67%;" />

```java
//外循环：几轮
//i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换
for (int i = 0; i < arr.length -1; i++) {
    //内循环：每一轮拿着i跟i后面的数据进行比较交换
    for (int j = i + 1; j < arr.length; j++) {
        if(arr[i] > arr[j]){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }}}
```

### 3.插入排序

**算法步骤（类似于打扑克时候的排序）**

1. 将0索引的元素到N索引的元素看做有序的，把N+1索引的元素到最后一个当成无序的。
2. 遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，遇到相同的数据插到后面。
   - N的范围：0~最大索引

<img src="tupian\image-20230203192934347.png" alt="image-20230203192934347" style="zoom:50%;" />

<img src="tupian\0charu.gif" alt="插入排序" style="zoom:67%;" />

```java
int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
//1.找到无序的那一组数据从哪个索引开始的    答：2
int startIndex = -1;//不存在的索引，默认值
for (int i = 0; i < arr.length; i++) {
    if (arr[i] > arr[i + 1]) {
        startIndex = i + 1;//表示有序的数据到1就结束了,无序的从i+1=2开始
        break;
    }
}
//2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素
for (int i = startIndex; i < arr.length; i++) {
    //问题：如何将遍历到的数据插入到前面有序的数组中
    //记录当前要插入数据的索引，因为i会不断修改
    int j = i;
    while (j > 0 && arr[j] < arr[j - 1]) {
        //如果当前元素小于前一个元素，就交换位置
        int temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
        j--;//交换位置后，记录的索引也发生了变化。
   }}
```

### 4.快速排序

快速排序是一种**分而治之**思想的典型应用。

**算法步骤**：

**第一轮**：

- 把0索引的数字作为基准数，再定义两个变量start和end分别指向0索引和最后索引。
- start从前往后找比基准数大的，end从后往前找比基准数小的。
- 找到之后交换start和end指向的元素，并循环这一过程，直至start和end处于同一位置，该位置是基准数存入的位置，让基准数和该位置数据互换。
  - **归位后效果**：**基准数左边的，一定比基准数小，基准数右边的，一定比基准数大**

**第二轮**：

- 重复第一轮的事情（**进行递归**），将原基准数左边数据进行快速排序
- 原基准数右边数据也进行快速排序，第三轮第四轮依次往下,直至**start>end(递归的出口)**。

**为什么要先移动end再移动start？**

如果start先移动，最后会停留在比基准数大的数字上，那么基准数归位时会出现问题。

如果以最大索引为基准数，则应该先移动start再移动end。

**非递归快速排序算法的实现：**利用栈进行实现

<img src="tupian\0kuaisu.gif" alt="快速排序" style="zoom:67%;" />

```java
//参数一：要排序的数组
//参数二：要排序数组的起始索引
//参数三：要排序树组的结束索引
public static void quickSort(int[] arr, int i, int j) {
    //定义两个变量记录要查找的范围
    int start = i;
    int end = j;
    
    if (start > end) {
        //递归的出口
        return;
    }
    //记录基准数
    int baseNumber = arr[i];
    
    //利用循环找要交换的数字
    while (start != end) {
        //利用end，从后往前找，找比基准数小的数字
        while(true){
            if(end <= start || arr[end] < baseNumber){
                break;
            }
            end--;//指针往前挪一个
        }
        //利用start,从前往后找，找比基准数大的数字
        while(true){
            if(end <= start || arr[start] > baseNumber){
                break;
            }
            start++;//指针往后挪一个
        }
        
        //把end和start指向的元素进行交换
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
    }
    //当start和end指向了同一个元素的时候，那么上面的循环就会结束
    //表示已经找到了基准数在数组中应存入的位置
    //基准数归位：就是拿着这个范围中的第一个数字，跟start指向的元素进行交换
    int temp = arr[i];
    arr[i] = arr[start];//or arr[i] = arr[end];
    arr[start] = temp;
    
    //确定原基准数左边的范围，重复刚刚的事情(递归调用)
    //start此时指向原基准数
    quickSort(arr, i, start - 1);
    //确定原基准数右边的范围
    quickSort(arr, start + 1,j);
}
```

### 5.归并排序

归并排序，是采用**分治法**的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度**仅次于快速排序**，缺点是**需要额外内存空间**。

一般用于对总体无序，但是各子项相对有序的数列。

归是递归，并是合并。

**算法步骤：**

1. 递归： 将要排序的原序列**通过递归**不断拆分为子序列（**一分为二**），直到每个子序列只剩下一个元素
2. 排序合并：不断合并相邻的两个子序列，合并的过程中顺便将两个子序列进行比较排序，直到合成一个大序列。

<img src="tupian\2f9f62d486be19b87a3f37f13eb75786.png" alt="img" style="zoom:50%;" />

### 6.堆排序

利用了**堆（Heap）**这种数据结构，堆是一种**完全二叉树**

**完全二叉树**是除最后一层以外是**满二叉树**，最后一层子节点都靠左对齐。

**满二叉树**就是他的每一层都存满了节点，没有多余的节点。

<img src="tupian\20210317153452794.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/20210317153436440.png" style="zoom: 80%;" /><img src="https://img-blog.csdnimg.cn/20210317153506627.png" alt="在这里插入图片描述" style="zoom:80%;" />

**大顶堆/大根堆：都满足左节点或右节点小于父节点**

<img src="tupian\image-20230204121512252.png" alt="image-20230204121512252" style="zoom:33%;" />

下标为i的节点父节点下标为：(i-1)/2

下标为i的节点左子节点下标为：i*2+1

下标为i的节点右子节点下标为：i*2+2

**小顶堆/小根堆：都满足左节点或右节点大于父节点**

**算法步骤：**

1.首先将待排序的数组构造成一个大顶堆，整个数组的最大值就是堆结构的顶端

2.将顶端的数与末尾的数交换，此时不满足了大顶堆要求，就进行堆的维护

3.维护后就重新构造了大顶堆，再将最小值与最大值互换，重复这个步骤直到所有数排序完毕

注意:从小到大用大顶堆，从大到小就用小顶堆(默认为升序)

<img src="tupian\213170918_17_20210116035832840.gif" alt="213170918_17_20210116035832840" style="zoom: 50%;" />

### 7.基数排序

**算法步骤：**

1. 首先将所有待比较数字统一为统一位数长度。不够的位数就补为0。

2. 接着从最低位开始，依次进行排序。按照个位数进行排序。按照十位数进行排序....
3. 排序后，数列就变成了一个有序序列。

<img src="tupian\88cb17eb223c8838182dcaff3dfcde17.png" alt="img" style="zoom:50%;" />

### 8.Shell排序（希尔排序：插入排序的改进算法）

希尔排序又名**缩减增量排序**，是一种**不稳定**的排序算法。希尔的时间复杂度取决于使用的间隙队列。

**当最大值在最左侧时**，进行插入排序时这个数会移动**数组的长度-1次**，效率低

<img src="tupian\image-20230203220845289.png" alt="image-20230203220845289" style="zoom: 80%;" />

**算法步骤**

1. 将要排序的数组分割成几个子序列，每个子序列间隔相同的增量
   - （增量范围在(1, 数组长度) 之间，一般来说**第一个增量为数组长度的一半**）

2. 对每个子序列进行插入排序；接着再缩小增量
   - （一般来说第二个增量为第一个增量的一半）

3. 分割成新的子序列进行插入排序......以此类推，最后增量缩减为1
4. 对所有元素进行最后一次插入排序。

<img src="tupian\042e746dcbcb46e0a6d749af778324c1.gif" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3Is6Arbg-1668608929993)(希尔排序.assets/动画.gif)]" style="zoom: 50%;" />



### 9.桶排序

桶排序也是利用了**分治思想**。

**算法步骤：**

1. 获得数组的最大值和最小值，确定数组元素分布的区间
2. 根据数组确定桶的数目和大小，桶内分隔不同的区间
3. 将数组中的元素按照区间放入桶中
4. 在桶内用冒泡排序选择排序等方法进行排序
5. 将所有桶按照区间进行合并输出。

<img src="tupian\sxbybdq396.gif" alt="img" style="zoom: 50%;" />

### 10.计数排序

适用于范围比较小的整数序列

**算法步骤：**

1. 找出待排序的数组中的最大值和最小值
2. 创建一个计数数组，长度是最大值-最小值+1
3. 计数数组中记录的值是原数组中的数值出现的次数
4. 最后遍历计数数组，输出相应元素以及对应的个数，就是1有两个就输出两个1...

<img src="tupian\25fdb31acd81f931cd443cb932140ab9.png" alt="img" style="zoom:50%;" />





![image-20210713170142593](tupian\a57f4d08d966f073b19808ed8b0014ef.jpeg)